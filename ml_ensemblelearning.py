# -*- coding: utf-8 -*-
"""Ml_Graded_EnsembleLearning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CSyQtzUsYcfaKMPsmyWYRg8CIybXCRe9

**ML BATCH 1**

**Assignment :**

to study and implement Ensemble Learning Algorithms and Comparative analysis

**Research Paper :**
Machine Learning Approaches for Classification and Diameter Prediction of Asteroids.



January 2023

DOI: 10.1007/978-981-19-7528-8_4

In book: Proceedings of International Conference on Information and Communication Technology for Development

Lab: Mir Sakhawat Hossain's Lab

Mir Sakhawat HossainMir Sakhawat HossainMd. Akib Zabed

from Research Gate

**Name :**

Omkar Awari 202101070094

Girish Amrutkar 202101070103

Piyush Girase 202101070111

## **1.Drive Mount**
"""

from google.colab import drive
drive.mount("/content/drive")

"""## **2.Research Paper**

https://drive.google.com/file/d/1-yg1o9KTrMjjUnMeiLj9a4FZK9K8xH7I/view?usp=sharing



The research paper focuses on utilizing machine learning approaches for the classification and diameter prediction of asteroids, which has become crucial due to the increasing complexity of data in astronomy.

 By employing various machine learning algorithms like **kNN, Logistic Regression, and XGBoost for classification, and Linear Regression, Decision Trees, and Neural Networks** for diameter prediction, the authors achieved a high accuracy rate of **99.99%**

  The document discusses the dataset used, preprocessing steps, feature analysis techniques, and reviews related works in the field. The methodology outlined includes detailed steps for classification and diameter prediction models.
  
   Key contributions include feature analysis, efficient asteroid classification, and diameter prediction using machine learning algorithms.

The paper also reviews previous works in the field of astronomy and asteroid classification, highlighting the lack of a diameter prediction model for asteroids.

The authors propose a model to classify 13 asteroid groups and predict asteroid diameters efficiently using machine learning regression algorithms.

The results show that the **XGBoost model outperformed other machine learning regression models in accuracy and performance for asteroid classification.**

Evaluation metrics such as mean squared error, mean absolute error, and root mean square error were used for diameter prediction models, showcasing the effectiveness of the applied models.

In conclusion, the paper provides a comprehensive analysis of the methodology, results, and future research directions in the field of asteroid classification and diameter prediction using machine learning approaches .

## **3.Reading Dataset**

https://drive.google.com/file/d/1-W0DyfLbgxjMsjhAAFsmHaVIGjoq9Ucg/view?usp=sharing

NASA JPL Asteroid Dataset

  collected this Dataset from kaggle  which is officially maintained by Jet Propulsion Laboratory of California Institute of Technology which is an organization under NASA.
  
   In this Dataset all kinds of Data related to Asteroid is included.
   
  This Dataset is publicly available in their website.

  ![image.png](data:image/png;base64,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)

unique values in the Dataset : 958524
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
df=pd.read_csv("/content/drive/MyDrive/DataSets/asteroid.csv")
df.head()

df.shape

df.columns

df.info()

df.isnull().sum()

df.isnull().sum() / len(df) * 100

"""## **4.Data Cleaning**"""

df = df.drop(['name', 'prefix'], axis=1)

df[df['pha'] == 'Y'].isnull().sum()

df = df.dropna()

df

plt.figure(figsize=(20,10))
plt.title('Count of Potentially Hazardous Asteroid (PHA) flag')
sns.countplot(data=df, x='pha');

len(df[df['pha'] == 'N'])

len(df[df['pha'] == 'Y'])

len(df[df['pha'] == 'Y'])/ len(df[df['pha'] == 'N']) * 100

df['equinox'].unique()

"""we will drop following columns

id

spkid

orbit_id

full_name

equinox
"""

df = df.drop(['id', 'spkid','full_name', 'equinox','orbit_id','pdes'], axis=1)

df

"""## **5.Heatmap**"""

df['class'].unique()

df['pha'] = df['pha'].map({'Y': 1, 'N': 0})

plt.figure(figsize=(20,20))
sns.heatmap(data=round(df.corr(),2), annot=True)

"""## **6.Encoding**"""

df= pd.get_dummies(df)
df

"""## **7.Splitting the Dataset**"""

X = df.drop('pha', axis=1)
y = df['pha']

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

X_train.shape

X_test.shape

y_train.shape

y_test.shape

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

"""## **8.Feature Selection**"""

import time
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import GridSearchCV

# Define the parameter grid
param_grid = {
    'criterion': ['gini', 'entropy'],
    'max_depth': [None, 10, 20, 30, 40, 50],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4],
    'max_features': ['auto', 'sqrt', 'log2', None]
}

# Initialize DecisionTreeClassifier
dt_classifier = DecisionTreeClassifier(random_state=42)

# Initialize GridSearchCV
grid_search = GridSearchCV(estimator=dt_classifier, param_grid=param_grid, cv=5, scoring='accuracy', n_jobs=-1)

# Record the start time
start_time = time.time()

# Fit the grid search to the data
grid_search.fit(X_train, y_train)

# Record the end time
end_time = time.time()

# Calculate the training time
training_time = end_time - start_time

# Print the best parameters found
print("Best parameters:", grid_search.best_params_)

# Build the decision tree using the best hyperparameters
best_dt_classifier = grid_search.best_estimator_

print("Training time: {:.2f} seconds".format(training_time))

import matplotlib.pyplot as plt
from sklearn.tree import plot_tree

# Visualize the decision tree with the best parameters
plt.figure(figsize=(15, 10))
plot_tree(best_dt_classifier, filled=True, feature_names=X.columns, class_names=['Non-Pha', 'Pha'])
plt.show()

# Get feature importances
feature_importances = best_dt_classifier.feature_importances_

# Create a dictionary to map feature names to their importance scores
feature_importance_dict = dict(zip(X.columns, feature_importances))

# Sort the dictionary by importance score in descending order
sorted_feature_importance = sorted(feature_importance_dict.items(), key=lambda x: x[1], reverse=True)

# Print feature importances
print("Feature Importance:")
for feature, importance in sorted_feature_importance:
    print("{}: {:.4f}".format(feature, importance))

import matplotlib.pyplot as plt

# Get feature importances
feature_importances = best_dt_classifier.feature_importances_

# Create a list of feature names
features = X.columns

# Sort feature importances and feature names in descending order of importance
sorted_indices = feature_importances.argsort()[::-1]
sorted_features = [features[i] for i in sorted_indices]
sorted_importances = feature_importances[sorted_indices]

# Plot the feature importances
plt.figure(figsize=(10, 6))
plt.bar(range(len(features)), sorted_importances, align='center')
plt.xticks(range(len(features)), sorted_features, rotation=90)
plt.xlabel('Feature')
plt.ylabel('Importance Score')
plt.title('Feature Importances')
plt.show()

# Set a threshold for feature importance
threshold = 0.01  # Adjust this threshold as needed

# Get feature importances
feature_importances = best_dt_classifier.feature_importances_

# Create a mask to identify features with importance below the threshold
mask = feature_importances > threshold

# Get the names of features to keep
features_to_keep = X.columns[mask]

# Filter the dataset to keep only the selected features
X_filtered = X[features_to_keep]

# Proceed with the remaining code for splitting and scaling the filtered data
X_train, X_test, y_train, y_test = train_test_split(X_filtered, y, test_size=0.3, random_state=42)

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

print("Size of X_train:", X_train.shape)
print("Size of X_test:", X_test.shape)
print("Size of y_train:", y_train.shape)
print("Size of y_test:", y_test.shape)

"""## **9.Models Training along with time and score**"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from xgboost import XGBClassifier, XGBRFClassifier
import time

def fit_and_score(models, X_train, X_test, y_train, y_test):
    np.random.seed(42)

    model_scores = {}
    model_times = {}

    for name, model in models.items():
        start_time = time.time()
        model.fit(X_train, y_train)
        end_time = time.time()
        model_times[name] = end_time - start_time
        model_scores[name] = model.score(X_test, y_test)

    model_scores_df = pd.DataFrame(model_scores, index=['Score']).transpose()
    model_scores_df = model_scores_df.sort_values('Score')

    model_times_df = pd.DataFrame(model_times, index=['Time (s)']).transpose()
    model_times_df = model_times_df.reindex(model_scores_df.index)  # Reindex to match the order of model_scores_df

    # Plotting scores
    plt.figure(figsize=(12, 6))
    sns.barplot(x=model_scores_df.index, y=model_scores_df['Score'], color='blue')
    plt.title('Model Scores')
    plt.xlabel('Model')
    plt.ylabel('Score')
    plt.xticks(rotation=45)
    plt.show()

    # Plotting training times
    plt.figure(figsize=(12, 6))
    sns.barplot(x=model_times_df.index, y=model_times_df['Time (s)'], color='red')
    plt.title('Training Time for Models')
    plt.xlabel('Model')
    plt.ylabel('Time (s)')
    plt.xticks(rotation=45)
    plt.show()

    # Combine scores and times into one DataFrame
    combined_df = pd.concat([model_scores_df, model_times_df], axis=1)

    return combined_df

models = {
    'LogisticRegression': LogisticRegression(max_iter=10000),
    'KNeighborsClassifier': KNeighborsClassifier(),
    'SVC': SVC(),
    'DecisionTreeClassifier': DecisionTreeClassifier(),
    'RandomForestClassifier': RandomForestClassifier(),
    'AdaBoostClassifier': AdaBoostClassifier(),
    'GradientBoostingClassifier': GradientBoostingClassifier(),
    'XGBClassifier': XGBClassifier(),
    'XGBRFClassifier': XGBRFClassifier()
}

baseline_model_scores = fit_and_score(models, X_train, X_test, y_train, y_test)

"""## **10.Ensemble Learning Model Evaluation**

### **1.Adaboost**
"""

model = AdaBoostClassifier()
model.fit(X_train,y_train)
y_preds = model.predict(X_test)

"""Classification Report"""

from sklearn.metrics import classification_report

# Assuming you have true labels 'y_true' and predicted labels 'y_pred'
print(classification_report(y_test, y_preds))

"""Confusion Matrix"""

from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Assuming you have true labels 'y_test' and predicted labels 'y_preds'
cm = confusion_matrix(y_test, y_preds)

# Plot confusion matrix as a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted labels')
plt.ylabel('True labels')
plt.show()

"""Auc-Roc Curve"""

from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Assuming you have the AdaBoostClassifier model named 'model' and the test features 'X_test'
y_preds_prob = model.predict_proba(X_test)[:, 1]  # Predict probabilities for the positive class

# Compute ROC curve
fpr, tpr, thresholds = roc_curve(y_test, y_preds_prob)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()

"""calculate evalution metrices using cross-validation"""

from sklearn.model_selection import cross_val_score

cv_acc = cross_val_score(model,X,y,cv=5,
                         scoring='accuracy')
cv_acc

cv_acc = cv_acc.mean()

cv_precision = cross_val_score(model,X,y,cv=5,
                         scoring='precision')
cv_precision

cv_precision.mean()

cv_recall = cross_val_score(model,X,y,cv=5,
                         scoring='recall')
cv_recall

cv_recall.mean()

cv_f1 = cross_val_score(model,X,y,cv=5,
                         scoring='f1')
cv_f1

cv_f1.mean()

cv_merics = pd.DataFrame({'Accuracy': cv_acc.mean(),
                         'Precision': cv_precision.mean(),
                         'Recall': cv_recall.mean(),
                         'f1': cv_recall.mean()},index=[0])
sns.barplot(data=cv_merics)
plt.title('CV scores')

cv_merics

"""Feature Importance

### **2.XGBClassifier**
"""

model = XGBClassifier()
model.fit(X_train,y_train)
y_preds = model.predict(X_test)

"""Classification Report"""

from sklearn.metrics import classification_report

print(classification_report(y_test, y_preds))

"""Confusion Matrix"""

from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns


cm = confusion_matrix(y_test, y_preds)

# Plot confusion matrix as a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted labels')
plt.ylabel('True labels')
plt.show()

"""Roc Curve"""

from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt

# Assuming you have the XGBClassifier model named 'model' and the test features 'X_test'
y_preds_prob = model.predict_proba(X_test)[:, 1]  # Predict probabilities for the positive class

# Compute ROC curve
fpr, tpr, thresholds = roc_curve(y_test, y_preds_prob)
roc_auc = auc(fpr, tpr)

# Plot ROC curve
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()

"""Calculate Evaluation metrics using Cross Validation"""

from sklearn.model_selection import cross_val_score
cv_acc = cross_val_score(model,X,y,cv=5,
                         scoring='accuracy')
cv_acc
cv_acc = cv_acc.mean()
cv_precision = cross_val_score(model,X,y,cv=5,
                         scoring='precision')
cv_precision
cv_precision.mean()
cv_recall = cross_val_score(model,X,y,cv=5,
                         scoring='recall')
cv_recall
cv_recall.mean()
cv_f1 = cross_val_score(model,X,y,cv=5,
                         scoring='f1')
cv_f1
cv_f1.mean()
cv_merics = pd.DataFrame({'Accuracy': cv_acc.mean(),
                         'Precision': cv_precision.mean(),
                         'Recall': cv_recall.mean(),
                         'f1': cv_recall.mean()},index=[0])
sns.barplot(data=cv_merics)
plt.title('CV scores')

cv_merics

import time
from xgboost import XGBClassifier
from sklearn.model_selection import GridSearchCV

# Define the parameter grid
param_grid = {
    'learning_rate': [0.01, 0.05, 0.1],
    'max_depth': [3, 5, 7],
    'n_estimators': [100, 200, 300]
}

# Initialize XGBClassifier
xgb_classifier = XGBClassifier()

# Initialize GridSearchCV
grid_search = GridSearchCV(estimator=xgb_classifier, param_grid=param_grid, cv=5, scoring='accuracy', n_jobs=-1)

# Record the start time
start_time = time.time()

# Fit the grid search to the data
grid_search.fit(X_train, y_train)

# Record the end time
end_time = time.time()

# Calculate the training time
training_time = end_time - start_time

# Print the best parameters found
print("Best parameters:", grid_search.best_params_)
print("Training time: {:.2f} seconds".format(training_time))

"""### **3.GradientBoostingClassifier**"""

from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
import matplotlib.pyplot as plt

# Initialize and train the GradientBoostingClassifier model
model = GradientBoostingClassifier()
model.fit(X_train, y_train)

# Predictions
y_preds = model.predict(X_test)
y_preds_prob = model.predict_proba(X_test)[:, 1]  # Predict probabilities for the positive class

"""Classification Report"""

# Classification Report
print("Classification Report:")
print(classification_report(y_test, y_preds))

"""Confusion Matrix"""

# Confusion Matrix
cm = confusion_matrix(y_test, y_preds)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted labels')
plt.ylabel('True labels')
plt.show()

"""Roc Curve"""

# ROC Curve
fpr, tpr, thresholds = roc_curve(y_test, y_preds_prob)
roc_auc = auc(fpr, tpr)

plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc="lower right")
plt.show()

import time
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report

# Define the parameter grid
param_grid = {
    'learning_rate': [0.01, 0.05, 0.1],
    'max_depth': [3, 5, 7],
    'n_estimators': [100, 200, 300]
}

# Initialize GradientBoostingClassifier
gb_classifier = GradientBoostingClassifier()

# Initialize GridSearchCV
grid_search = GridSearchCV(estimator=gb_classifier, param_grid=param_grid, cv=5, scoring='accuracy', n_jobs=-1)

# Record the start time
start_time = time.time()

# Fit the grid search to the data
grid_search.fit(X_train, y_train)

# Record the end time
end_time = time.time()

# Calculate the training time
training_time = end_time - start_time

# Print the best parameters found
print("Best parameters:", grid_search.best_params_)
print("Training time: {:.2f} seconds".format(training_time))

# Make predictions on the test data using the best estimator
y_pred = grid_search.best_estimator_.predict(X_test)

# Print classification report
print("Classification Report:")
print(classification_report(y_test, y_pred))

"""### **4.Cat-Boost**"""

pip install catboost

from catboost import CatBoostClassifier

# Initialize the CatBoostClassifier
catboost_model = CatBoostClassifier()

# Fit the model to the training data
catboost_model.fit(X_train, y_train)

# Make predictions on the test data
y_preds_catboost = catboost_model.predict(X_test)

import time
from catboost import CatBoostClassifier
from sklearn.model_selection import GridSearchCV
import matplotlib.pyplot as plt

# Record the start time
start_time = time.time()

# Define the parameter grid
param_grid = {
    'learning_rate': [0.01, 0.05, 0.1],
    'depth': [3, 5, 7],
    'iterations': [100, 200, 300]
}

# Initialize CatBoostClassifier
catboost_classifier = CatBoostClassifier()

# Initialize GridSearchCV
grid_search = GridSearchCV(estimator=catboost_classifier, param_grid=param_grid, cv=5, scoring='accuracy', n_jobs=-1)

# Fit the grid search to the data
grid_search.fit(X_train, y_train)

# Record the end time
end_time = time.time()

# Calculate the training time
training_time = end_time - start_time

# Get the results
results = grid_search.cv_results_
mean_test_score = results['mean_test_score']
params = results['params']

# Plot the evaluation metrics
fig, ax = plt.subplots(1, figsize=(10, 6))
for i, param in enumerate(params):
    ax.plot(i, mean_test_score[i], 'bo', label='{}'.format(param))
ax.set_xlabel('Parameter Set')
ax.set_ylabel('Mean Test Score')
ax.set_title('Evaluation Metrics for Different Hyperparameters')
ax.legend()
plt.xticks(range(len(params)), range(1, len(params) + 1))
plt.grid(True)
plt.show()

# Print the best parameters found
print("Best parameters:", grid_search.best_params_)
print("Training time: {:.2f} seconds".format(training_time))

from sklearn.metrics import classification_report

# Make predictions on the test data using the best estimator
y_pred = grid_search.best_estimator_.predict(X_test)

# Print classification report
print("Classification Report:")
print(classification_report(y_test, y_pred))

"""## **11.Conclusion**

Different models from ensemble learning that are implemented above gives us different feature importances in each model.
Similarly the Evaluation Metrices for the models are changed once we performed cross validation technique.
We also found that training time is highest for the ensemble learning models.
"""

import matplotlib.pyplot as plt

# Models and their parameters
models = ['CatBoost', 'XGBoost', 'Gradient Boosting']
parameters = [{'depth': 3, 'iterations': 100, 'learning_rate': 0.01},
              {'learning_rate': 0.01, 'max_depth': 3, 'n_estimators': 100},
              {'learning_rate': 0.01, 'max_depth': 3, 'n_estimators': 300}]

# Training times
training_times = [504.26, 87.80, 607.39]

# Plotting
plt.figure(figsize=(10, 6))
plt.barh(models, training_times, color=['blue', 'green', 'red'])
plt.xlabel('Training Time (seconds)')
plt.ylabel('Models')
plt.title('Training Time Comparison using grid search CV ')
plt.xlim(0, max(training_times) * 1.1)
for i, time in enumerate(training_times):
    plt.text(time + 10, i, str(time), va='center')
plt.show()